<!DOCTYPE html>
<html>

<head>
    <title>GLTF Loader</title>
    <style>
        * { box-sizing: border-box; }
        body { overflow: hidden; margin: 0; padding: 0; }
        .container { position: relative; display: block; }
        canvas { position: relative; }
        button { background: none; border: 0; cursor: pointer;}
        .buttons__inner { position: absolute; left: 50%; bottom: 100px; transform: translateX(-50%); display: block; z-index: 1;}
        .switch-scene__box { margin-bottom: 10px; }
        .switch-scene__box button { border: 2px solid rgb(32, 76, 143); color: #fff; padding: 5px 10px; }
        .animation__box { margin-bottom: 10px; }
        .animation__box button{ border: 2px solid rgb(36, 177, 111); color: #fff; padding: 5px 10px; }
        .colorchip__box { }
        .colorchip__box button.select{ border: 2px solid #fff; }
        #satinGray { background: #292929; border-radius: 50%; width: 25px; height: 25px; }
        #warmGreige { background: #cbcbcc; border-radius: 50%; width: 25px; height: 25px; }
    </style>
    <script type="importmap">
        {
            "imports": {
            "three": "https://unpkg.com/three/build/three.module.js",
            "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div class="container">
        <div class="buttons__inner">
            <div class="switch-scene__box">
                <button id="front">Front</button>
                <button id="back">Back</button>
                <button id="left">Left</button>
                <button id="right">Right</button>
                <button id="top">Top</button>
                <button id="bottom">Bottom</button>
            </div>
            <div class="animation__box">
                <button id="animation1">Animation 1</button>
                <button id="animation2">Animation 2</button>
                <button id="animation3">Animation 3</button>
            </div>
            <div class="colorchip__box">
                <button id="satinGray" class="select"></button>
                <button id="warmGreige"></button>
            </div>
        </div>
        <canvas id="MyCanvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
        const frontButton = document.querySelector('#front');
        const backButton = document.querySelector('#back');
        const leftButton = document.querySelector('#left');
        const rightButton = document.querySelector('#right');
        const topButton = document.querySelector('#top');
        const bottomButton = document.querySelector('#bottom');
        const animation1 = document.querySelector('#animation1');
        const animation2 = document.querySelector('#animation2');
        const animation3 = document.querySelector('#animation3');
        const satinGrayButton = document.querySelector('#satinGray');
        const warmGreigeButton = document.querySelector('#warmGreige');

        const pearl_light_arr = ["lid_part1","lid_part2","lid_part3","pearl_light_parent","개체_32","개체_33"];
        const pearl_dark_arr = ["drawer","pearl_dark_parent","개체_3","개체_11","개체_14","개체_15","개체_16","개체_17","개체_18","개체_20","개체_22001","개체_45","개체_46","개체_58","handle_inside"];
        const pearl_glossy_arr = ["handle_outside"];
        
        let renderer, scene, camera, controls, objectCenter, mixer;
        let texture, gltfSatinGray, gltfWarmGerige, envMap; // hdr, glb, envm gltfModel
        let currentGlb;
        let targetPosition = new THREE.Vector3();
        let isAnimating = false;
        let animationInProgress = false;
        let actions = [];
        let animationStates = []; // Track animation states (playing or paused)
        
        init().catch(err => console.error(err));
        
        async function init() {
            setupRenderer();
            setupScene();
            setupCamera();
            setupControls();

            await loadModel();
            setMaterialAnimation(gltfSatinGray);
        
            window.addEventListener('resize', onWindowResize);
            setupButtons();
        }
        
        // 렌더러 설정
        function setupRenderer() {
            renderer = new THREE.WebGLRenderer({ canvas: MyCanvas, antialias: true });
            renderer.setAnimationLoop(render);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // 매핑 노출 수준 설정
            renderer.toneMappingExposure = 1;
            renderer.outputEncoding = THREE.sRGBEncoding;
        }
        
        // 3D scene 설정
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
        }
        
        function setupCamera() {
            camera = new THREE.PerspectiveCamera(0.5, window.innerWidth / window.innerHeight, 0.05, 20);
            // camera.position.set(2, 2, 2.5);
            camera.position.set(0, 0, 0);
            camera.enablePan = false;
            camera.lookAt(0, 0, 0);
        }
        
        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 1.5;
            controls.maxDistance = 10;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.target.set(0, 0.2, 0);
            controls.update();
        }

        async function loadModel(){
            const rgbeLoader = new RGBELoader();
            const dracoLoader = new DRACOLoader();

            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/')

            const gltfLoader = new GLTFLoader().setPath('/threeKlug/glb/');
            gltfLoader.setDRACOLoader(dracoLoader);

            [texture, gltfSatinGray, gltfWarmGerige] = await Promise.all([
                rgbeLoader.loadAsync('https://cdn.shopify.com/s/files/1/0738/7584/9516/files/env-map-camera-highlight-fold6.hdr?v=1722497474'),
                gltfLoader.loadAsync('test_0.01x.glb'),
                // gltfLoader.loadAsync('klug_disposer_v10_0807(lv6_comp_light).glb'),
                gltfLoader.loadAsync('test_0.01x.glb'),
            ]);
        
            envMap = texture;
            envMap.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envMap;
        }
        function setMaterial(glbObject) {

            const material_light = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 1.0,
                roughness: 0.342,
                envMap: envMap,
            });

            const material_dark = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 1.0,
                roughness: 0.342,
                envMap: envMap,
            });

            const material_glossy = new THREE.MeshStandardMaterial({
                color: 0x666666,
                metalness: 1.0,
                roughness: 0.1,
                envMap: envMap,
            });

            glbObject.scene.traverse((child) => {
                if(child.isMesh) {
                    pearl_light_arr.forEach(childName => {
                        if(child.name === `${childName}`){
                            // console.log(child.name);
                            child.material = material_light;
                        }
                    });
                    pearl_dark_arr.forEach(childName => {
                        if(child.name === `${childName}`){
                            // console.log(child.name);
                            child.material = material_dark;
                        }
                    });
                    pearl_glossy_arr.forEach(childName => {
                        if(child.name === `${childName}`){
                            // console.log(child.name);
                            child.material = material_glossy;
                        }
                    });
                }
            });
        }
        
        // 텍스처 환경 세팅, 모델 애니메이션 세팅 
        function setMaterialAnimation(glbObject) {
            if(currentGlb) {
                if(currentGlb.scene == glbObject.scene) console.log(true);
            }
            currentGlb = glbObject;
            if(glbObject === gltfSatinGray) setMaterial(glbObject);

            if (mixer) mixer.stopAllAction();
            actions = [];

            const gltfModel = glbObject.scene;
            console.log("gltfModel --> ", gltfModel);
            scene.clear();
            scene.add(gltfModel);
        
            objectCenter = new THREE.Vector3();
            const box = new THREE.Box3().setFromObject(gltfModel);
            box.getCenter(objectCenter);
        
            controls.target.copy(objectCenter);

        
            mixer = new THREE.AnimationMixer(gltfModel);
            glbObject.animations.forEach((clip, index) => {
                const action = mixer.clipAction(clip);
                actions.push(action);
                animationStates[index] = { isPlaying: false, time: 0 }; // Initialize animation states
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }
        
        function render() {
            controls.update();
            if (mixer) mixer.update(0.01);
            renderer.render(scene, camera);
        }
        
        function setupButtons() {
            frontButton.addEventListener('click', () => setCameraTarget(0, objectCenter.y, objectCenter.z + 5));
            backButton.addEventListener('click', () => setCameraTarget(0, objectCenter.y, objectCenter.z - 5));
            leftButton.addEventListener('click', () => setCameraTarget(objectCenter.x - 5, objectCenter.y, 0));
            rightButton.addEventListener('click', () => setCameraTarget(objectCenter.x + 5, objectCenter.y, 0));
            topButton.addEventListener('click', () => setCameraTarget(objectCenter.x, objectCenter.y + 5, 0));
            bottomButton.addEventListener('click', () => setCameraTarget(objectCenter.x, objectCenter.y - 5, 0));
        
            // frontButton.addEventListener('click', () => setCameraTarget(0.0413, 0.0584, 3.6274));
            // backButton.addEventListener('click', () => setCameraTarget(0.0320, 0.0405, -3.6817));
            // leftButton.addEventListener('click', () => setCameraTarget(-3.6584, 0.1304, -0.0641));
            // rightButton.addEventListener('click', () => setCameraTarget(3.6604, 0.2018, -0.0185));
            // topButton.addEventListener('click', () => setCameraTarget(-0, 3.9248, -0.0276));
            // bottomButton.addEventListener('click', () => setCameraTarget(-0, -3.9248, -0.0276));

            animation1.addEventListener('click', () => toggleAnimation([0,1,2]));
            animation2.addEventListener('click', () => toggleAnimation([3]));
            animation3.addEventListener('click', () => toggleAnimation([4]));
            
            satinGrayButton.addEventListener("click", () => setMaterialAnimation(gltfSatinGray));
            warmGreigeButton.addEventListener("click", () =>setMaterialAnimation(gltfWarmGerige));
        }
        
        function setCameraTarget(x, y, z) {
            targetPosition.set(x, y, z);
            if (!isAnimating) {
                isAnimating = true;
                requestAnimationFrame(animateCamera);
            }
        }
        
        function animateCamera() {
            const speed = 0.035;
            const distance = camera.position.distanceTo(targetPosition);
        
            if (distance > 0.5) {
                camera.position.lerp(targetPosition, speed);
                camera.lookAt(objectCenter);
                controls.update();
                controls.enabled = false;
                requestAnimationFrame(animateCamera);
            } else {
                controls.enabled = true;
                isAnimating = false;
            }
        }

        function toggleAnimation(indices) {
            indices.forEach(index => {
                if (!mixer || !actions[index]) return;

                const action = actions[index];
                const state = animationStates[index];

                console.log("actione -> ", action);
                console.log("state -> ", state);

                if (!state.isPlaying) {
                    startAnimation(action, state);
                } else {
                    togglePlaybackDirection(action);
                }

                ensureLoopOnce(action);
                monitorAnimation(action, state);

                mixer.addEventListener('finished', (e) => {
                    if (e.action === action) {
                        console.log("Animation finished");
                        state.isPlaying = false;
                    }
                });
            });
        }

        function startAnimation(action, state) {
            action.reset();
            action.play();
            action.paused = false;
            action.timeScale = 2; // Forward playback direction
            state.isPlaying = true;
            state.time = action.time;
        }

        function togglePlaybackDirection(action) {
            action.paused = false;
            action.timeScale = action.timeScale === 2 ? -2 : 2;
        }

        function ensureLoopOnce(action) {
            action.setLoop(THREE.LoopOnce);
        }

        function monitorAnimation(action, state) {
            const pauseThreshold = 0.1; 

            function checkTime() {
                if (!state.isPlaying) return;
                const remainingTime = action.getClip().duration - action.time;
                if (remainingTime <= pauseThreshold) {
                    action.paused = true;
                    state.isPlaying = true;
                    console.log("pause Animation");
                } else {
                    requestAnimationFrame(checkTime);
                }
            }

            requestAnimationFrame(checkTime);
        }

        controls.addEventListener("change", () => {
            // console.log(`Camera Position: x=${camera.position.x}, y=${camera.position.y}, z=${camera.position.z}`);
        });
    </script>
    
    
</body>

</html>

